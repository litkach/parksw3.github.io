---
layout: post
title: "Estimating the basic reproduction number of MERS"
---

I came across an interesting package a few days ago that contains various epidemic data. MERS...

Let's look at the structure first

```R
library(numDeriv)
library(dplyr)
library(ggplot2); theme_set(theme_bw())
library(bbmle)
library(outbreaks)
str(mers_korea_2015)
```

```R
## List of 2
##  $ linelist:'data.frame':	162 obs. of  15 variables:
##   ..$ id            : chr [1:162] "SK_1" "SK_2" "SK_3" "SK_4" ...
##   ..$ age           : int [1:162] 68 63 76 46 50 71 28 46 56 44 ...
##   ..$ age_class     : chr [1:162] "60-69" "60-69" "70-79" "40-49" ...
##   ..$ sex           : Factor w/ 2 levels "F","M": 2 1 2 1 2 2 1 1 2 2 ...
##   ..$ place_infect  : Factor w/ 2 levels "Middle East",..: 1 2 2 2 2 2 2 2 2 2 ...
##   ..$ reporting_ctry: Factor w/ 2 levels "China","South Korea": 2 2 2 2 2 2 2 2 2 1 ...
##   ..$ loc_hosp      : Factor w/ 13 levels "365 Yeollin Clinic, Seoul",..: 10 10 10 10 1 10 10 13 10 10 ...
##   ..$ dt_onset      : Date[1:162], format: "2015-05-11" "2015-05-18" "2015-05-20" "2015-05-25" ...
##   ..$ dt_report     : Date[1:162], format: "2015-05-19" "2015-05-20" "2015-05-20" "2015-05-26" ...
##   ..$ week_report   : Factor w/ 5 levels "2014_21","2014_22",..: 1 1 1 2 2 2 2 2 2 2 ...
##   ..$ dt_start_exp  : Date[1:162], format: "2015-04-18" "2015-05-15" "2015-05-16" "2015-05-16" ...
##   ..$ dt_end_exp    : Date[1:162], format: "2015-05-04" "2015-05-20" "2015-05-16" "2015-05-20" ...
##   ..$ dt_diag       : Date[1:162], format: "2015-05-20" "2015-05-20" "2015-05-21" "2015-05-26" ...
##   ..$ outcome       : Factor w/ 2 levels "Alive","Dead": 1 1 2 1 1 2 1 1 1 1 ...
##   ..$ dt_death      : Date[1:162], format: NA NA "2015-06-04" NA ...
##  $ contacts:'data.frame':	98 obs. of  4 variables:
##   ..$ from         : chr [1:98] "SK_14" "SK_14" "SK_14" "SK_14" ...
##   ..$ to           : chr [1:98] "SK_113" "SK_116" "SK_41" "SK_112" ...
##   ..$ exposure     : Factor w/ 5 levels "Contact with HCW",..: 2 2 2 2 2 2 2 2 2 2 ...
##   ..$ diff_dt_onset: int [1:98] 10 13 14 14 15 15 15 16 16 16 ...
```

I want to estimate some parameters...

Exponential growth rate
===

```R
mers_time <- mers_korea_2015$linelist[,grepl("dt", names(mers_korea_2015$linelist))]
mers_time$dt_death[47] <- "2015-06-08" ## There's a typo
mers_time <- apply(mers_time, 2, as.POSIXct)
min_time <- min(mers_time, na.rm=TRUE)
mers_time <- as.data.frame((mers_time - min_time)/86400)
```

plots...

```R
mers_list <- apply(mers_time[,names(mers_time) %in% c("dt_onset", "dt_report", "dt_diag")], 2, table) %>%
    lapply(as.data.frame) %>%
    lapply(. %>% setNames(c("times", "count")) %>% mutate(times=as.integer(as.character(times))))

mers_cc <- mers_list %>%
    bind_rows(.id="type") %>%
    group_by(type) %>%
    mutate(count=cumsum(count))

ggplot(mers_cc, aes(times, count, color=type)) + 
    geom_point() +
    scale_y_log10() +
    geom_smooth(method="lm", se=FALSE)
```

They all have similar slopes!

```R
mers_growth <- mers_cc %>% 
    do(lm=lm(log(count)~times, data=.)) %>%
    mutate(r=coef(lm)[2]) %>%
    select(-lm)

print(mers_growth)
```

So $r \approx 0.14-0.18$ days superscript-1?? doubling period of 3.8-5 days. Estimate from `dt_onset` is particularly low probably because it is missing some values. Following Ma et al. 2014, We can even try mle using bbmle package..

```R
flogis <- function(t, param) {
    with(as.list(param), {
        K/(1 + (K/c0 -1) * exp(-r * t))
    })
}

logisll <- function(param, count, times) {
    mean <- flogis(times, param)
    -sum(dpois(count, mean, log=TRUE))
}
attr(logisll, "parnames") <- c("r", "K", "c0")

par_range <- data.frame(
    min=c(0.1, 100, 1e-3),
    max=c(0.3, 300, 1),
    row.names=c("r","K", "c0")
)
set.seed(101)
ltab <- as.data.frame(apply(par_range, 1, function(x) exp(seq(log(x[1]), log(x[2]), length=20))))

ltab[] <- lapply(ltab, sample)

mle3 <- function(data) {
    mlist <- apply(ltab, 1, function(x){
        mle2(logisll,
            vecpar=TRUE,
            start=x,
            method="Nelder-Mead",
            control=list(maxit=1e5),
            data=c(data))
    })
    mlist[[which.max(sapply(mlist, logLik))]]
}

mres <- mers_cc %>%
    split(.$type) %>%
    lapply(. %>% mle3 %>% coef %>% as.matrix %>% t %>% as.data.frame) %>%
    bind_rows(.id="type")
    
print(mres)
```

Exponential growth rate of 0.21-0.29 and doubling preiod of about 2.4 to 3.3 days. Can I cite something???

Smaller final size for onset. Actually, we are missing 27 observations! So this is all consistent...

```R
mers_curve <- mres %>%
    split(.$type) %>%
    lapply(function(x) append(list(param=x), list(t=mers_list[[x$type]]$times))) %>%
    lapply(function(x) data.frame(times=x$t, count=do.call(flogis, x))) %>%
    bind_rows(.id="type")
    
ggplot(mers_cc, aes(times, count, colour=type)) +
    geom_point() + 
    geom_line(data=mers_curve, lwd=1)
```

Now that we've estimated little r, let's try to estimate some other parameters. How about incubation period?

Incubation period
=====

I need some theory here...

Exposure $s$ to $t$, uniformly distributed between this period. And then incubation period. How do I do this using MLE?

I removed two values with 0 incubation period
If dt_end_exp > dt_onset, I set the last exposure date was equal to onset date

```R
inc_list <- mers_time %>%
    select(dt_onset, dt_start_exp, dt_end_exp) %>%
    filter(complete.cases(.)) %>%
    mutate(dt_start_exp=dt_start_exp-(dt_onset==dt_start_exp)) %>%
    mutate(dt_end_exp=ifelse(dt_end_exp >= dt_onset, dt_onset, dt_end_exp)) %>%
    mutate(censor=dt_end_exp!=dt_start_exp) %>%
    split(.$censor)

names(inc_list) <- c("nc","yc")

inc_list$nc <- with(inc_list$nc, dt_onset-dt_start_exp)
inc_list$yc <- inc_list$yc %>%
    mutate(max=dt_onset-dt_start_exp, min=dt_onset-dt_end_exp) %>%
    select(min, max)
    
incubation_mle <- function(shape, scale,  
                           nc=inc_list$nc, 
                           yc=inc_list$yc) {
    nc_nll <- -sum(dgamma(x=nc, shape=shape, scale=scale, log=TRUE))
    yc_nll <- -sum(log(apply(yc, 1, function(x) diff(pgamma(q=x, shape=shape, scale=scale)))))
    
    nc_nll+yc_nll
}

m <- mle2(incubation_mle,
    start=list(shape=5, scale=1),
    method="Nelder-Mead",
    control=list(maxit=1e5),
    data=NULL)

print(inc_pars <- coef(m))
```

We find that the mean incubation period is 7.1 (CITE this is slightly different from the estimate provided by another source). So I tried to come up with a way to plot this thing...


```R
yc_mean <- apply(inc_list$yc, 1, mean)
inc_set <- c(inc_list$nc, yc_mean)
inc_data <- data.frame(x=rank(inc_set, ties.method="first")/length(inc_set), y=inc_set)

inc_data_c <- inc_data[-(1:length(inc_list$nc)),] %>% 
    filter(y %in% yc_mean) %>%
    cbind(inc_list$yc)
    
inc_p <- ppoints(2000)
inc_fit <- data.frame(x=inc_p, y=do.call(qgamma, append(as.list(coef(m)), list(inc_p))))

ggplot(inc_data, aes(y, x)) + 
    geom_point() +
    geom_errorbarh(data=inc_data_c, aes(xmin=min, xmax=max)) +
    geom_line(data=inc_fit, col="#F8766D", lwd=1) +
    scale_x_continuous(expand=c(0,0.05), name="incubation period") +
    scale_y_continuous(expand=c(0,0), name="quantile") +
    theme(axis.line = element_line(colour = "black"),
        panel.border = element_blank(),
        panel.background = element_blank())
```

Generation Interval
====

serial interval = - incubation period of p1 + generation interval + incubation period of p2

Following Nishiura, we assume that incubation period and generation interval are correlated. Assuming that generation distribution also follows a gamma distribution, we get a three parameter estimation problem (2 parameters for the gamma distribution and correlation coefficient). Can we do MLE?

...

Instead of doing MLE, we can also try to come up with a filtering algorithm...

$$
\begin{aligned}
P(G=y|S=x) &= P(I2 - I1 = x-y)\\
&= \int_{\mathrm{max}(y-x, 0)}^\infty P(i2 = s + x - y,i1= s) ds\\
&= \int_{\mathrm{max}(y-x, 0)}^\infty P(I2 = s + x - y) P(I1 = s) ds
\end{aligned}
$$

Using the empirical distribution, we can find $P(S=x)$. Then, we can filter the empirical distribution to find the approximate generation distribution:

$$
\begin{aligned}
P(G=y) &\approx \sum_{x} P(G=y|S=x) P(S = x)\\
\end{aligned}
$$

So we're interested in computing

$$
\int_{\mathrm{max}(y-x, 0)}^\infty P(I2 = s + x - y) P(I1 = s) ds.
$$

Does `numDeriv` package allow us to do this? I think so.

```R
dgamma2 <- function(x) dgamma(x, shape=inc_pars[1], scale=inc_pars[2])

filter_inc <- function(x, y) {
    res <- integrate(function(s) dgamma2(s + x - y) * dgamma2(s), lower = max(y-x, 0), upper = Inf)
    res$value
}

mers_serial <- mers_korea_2015$contacts[4] %>%
    table %>%
    as.data.frame %>%
    setNames(c("serial", "prop")) %>%
    mutate(serial = as.numeric(as.character(serial))) %>%
    mutate(prop=prop/sum(prop))

find_gen <- function(y) {
    with(as.list(mers_serial), {
        sum(sapply(serial, function(x) filter_inc(x, y)) * prop)
    })
}

plot(mers_serial, type="h", xlim=c(0,28))
points(0:28, sapply(0:28, find_gen)) ## need to integrat this from x-0.5 to x+0.5...
```

Misc
===

fitsir..

```R
library(fitsir)
summary(ff<-fitsir(mers_list$dt_diag, type="incidence", dist="poisson",method="BFGS"))
with(as.list(mers_list$dt_diag), plot(times, cumsum(count)))
lines((predict(ff) %>% mutate(mean2 = cumsum(mean)))[,-2])
plot(ff, level=0.95)
```
